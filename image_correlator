import ij.*;
import ij.IJ;
import ij.WindowManager;
import ij.process.*;
import ij.gui.*;
import ij.gui.PointRoi;
import ij.gui.ImageWindow;
import java.awt.*;
import ij.plugin.*;
import java.util.*;
import ij.plugin.frame.RoiManager;
import ij.plugin.filter.PlugInFilter;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.util.Arrays;
import javax.swing.*;
import java.lang.*;

public class Image_Correlator_AL_2 implements PlugIn {
    public void run(String arg) {
        int stackSize;
        int dialogLocX = 1000;
        int dialogLocY = 0;
        int vidLocX = 1000;
        int vidLocY = 500;
        int countAD = 0;
        int countAS = 0;
        int countVD = 0;
        int countVS = 0;
        int tableRow = 0;
        int iteratorA = 0;
        int iteratorV = 0;
        String temp;
        double corrAD;
        double corrAS;
        double corrVD;
        double corrVS;
        double sum = 0;
        ImageStack stack;
        Roi atriumRoiD;
        Roi atriumRoiS;
        Roi ventricleRoiD;
        Roi ventricleRoiS;
        double[] frameNum;
        double[] rNum;
        double[] rNum2;
        double[] rNum3;
        double[] rNum4;
        double[] pixelValuesAD;
        double[] pixelValuesAD2;
        double[] pixelValuesAS;
        double[] pixelValuesAS2;
        double[] pixelValuesVD;
        double[] pixelValuesVD2;
        double[] pixelValuesVS;
        double[] pixelValuesVS2;
        String[][] tableData;
        final String vidName;
        Window frontWindow;
        Frame rTable=new JFrame();
        JButton button;
        
        IJ.setTool("freehand");
        ImagePlus imp = IJ.getImage();
        stack = imp.getStack();
        stackSize = stack.getSize();
        tableData = new String[stackSize][5];
        
        //convert video to 8-bit grayscale
        for (int i=1;i<=stack.getSize();i++) {
            imp.setSlice(i);
            ImageConverter ic = new ImageConverter(imp);
            ic.convertToGray8();
            imp.updateAndDraw();
        }
        
        vidName = imp.getTitle();
        IJ.selectWindow(vidName); //also doesn't do what it purports
        ImageWindow vid = new ImageWindow(vidName);
        vid.setLocation(vidLocX,vidLocY);
        
        //get atrium ROI(diastole)
        WaitForUserDialog waitA = new WaitForUserDialog("User input",
                                                        "Outline the atrium (diastole), then press OK.");
        waitA.setLocation(dialogLocX,dialogLocY);
        waitA.toBack(); //doesn't do what it purports
        waitA.show();
        
        
        atriumRoiD = imp.getRoi();
        
        RoiManager rm = RoiManager.getInstance();
        if (rm == null){
            
            rm = new RoiManager();
        }
        rm.addRoi(atriumRoiD);
        rm.toBack();
        
        if (atriumRoiD!=null && !atriumRoiD.isArea()) atriumRoiD = null;
        ImageProcessor ip = imp.getProcessor();
        ImageProcessor maskAD = atriumRoiD!=null?atriumRoiD.getMask():null;
        Rectangle rAD = atriumRoiD!=null?atriumRoiD.getBounds():new Rectangle(0,0,ip.getWidth(),ip.getHeight());
        
        for (int y=0; y<rAD.height; y++) {
            for (int x=0; x<rAD.width; x++) {
                if (maskAD==null||maskAD.getPixel(x,y)!=0) {
                    countAD++;
                    //sum += ip.getPixelValuesA(x+r.x, y+r.y);
                }
            }
        }
        
        pixelValuesAD = new double[countAD];
        for (int y=0; y<rAD.height; y++) {
            for (int x=0; x<rAD.width; x++) {
                if (maskAD==null||maskAD.getPixel(x,y)!=0) {
                    pixelValuesAD[iteratorA]=ip.getPixelValue(x+rAD.x, y+rAD.y);
                    iteratorA++;
                }
            }
        }
        iteratorA = 0;

        //get atrium ROI(systole)
        WaitForUserDialog waitA2 = new WaitForUserDialog("User input",
                                                         "Outline the atrium (systole), then press OK.");
        waitA2.toBack();
        waitA2.show();
        atriumRoiS = imp.getRoi();
        
        rm.addRoi(atriumRoiS);
        
        if (atriumRoiS!=null && !atriumRoiS.isArea()) atriumRoiS = null;
        ImageProcessor maskAS = atriumRoiS!=null?atriumRoiS.getMask():null;
        Rectangle rAS = atriumRoiS!=null?atriumRoiS.getBounds():new Rectangle(0,0,ip.getWidth(),ip.getHeight());
        
        for (int y=0; y<rAS.height; y++) {
            for (int x=0; x<rAS.width; x++) {
                if (maskAS==null||maskAS.getPixel(x,y)!=0) {
                    countAS++;
                    //sum += ip.getPixelValuesAS(x+rAS.x, y+rAS.y);
                }
            }
        }
        
        pixelValuesAS = new double[countAS];
        for (int y=0; y<rAS.height; y++) {
            for (int x=0; x<rAS.width; x++) {
                if (maskAS==null||maskAS.getPixel(x,y)!=0) {
                    pixelValuesAS[iteratorA]=ip.getPixelValue(x+rAS.x, y+rAS.y);
                    iteratorA++;
                }
            }
        }
        iteratorA = 0;
        
        //get ventricle ROI(diastole)
        WaitForUserDialog waitV = new WaitForUserDialog("User input",
                                                        "Outline the ventricle (diastole), then press OK.");
        waitV.toBack();
        waitV.show();
        ventricleRoiD = imp.getRoi();
        
        rm.addRoi(ventricleRoiD);
        
        if (ventricleRoiD!=null && !ventricleRoiD.isArea()) ventricleRoiD = null;
        ImageProcessor maskVD = ventricleRoiD!=null?ventricleRoiD.getMask():null;
        Rectangle rVD = ventricleRoiD!=null?ventricleRoiD.getBounds():new Rectangle(0,0,ip.getWidth(),ip.getHeight());
        //^bounding RECTANGLE vs. non-rectangular shape issue
        
        for (int y=0; y<rVD.height; y++) {
            for (int x=0; x<rVD.width; x++) {
                if (maskVD==null||maskVD.getPixel(x,y)!=0) {
                    countVD++;
                }
            }
        }
        
        pixelValuesVD = new double[countVD];
        for (int y=0; y<rVD.height; y++) {
            for (int x=0; x<rVD.width; x++) {
                if (maskVD==null||maskVD.getPixel(x,y)!=0) {
                    pixelValuesVD[iteratorV]=ip.getPixelValue(x+rVD.x, y+rVD.y);
                    iteratorV++;
                }
            }
        }
        iteratorV = 0;
        
        //get ventricle ROI(systole)
        WaitForUserDialog waitV2 = new WaitForUserDialog("User input",
                                                         "Outline the ventricle (systole), then press OK.");
        waitV2.toBack();
        waitV2.show();
        ventricleRoiS = imp.getRoi();
        
        rm.addRoi(ventricleRoiS);
        //Save ROIs
        //rm.runCommand("Save", "/Users/Home_AL/Documents/RoiTest.zip");
        
        if (ventricleRoiS!=null && !ventricleRoiS.isArea()) ventricleRoiS = null;
        ImageProcessor maskVS = ventricleRoiS!=null?ventricleRoiS.getMask():null;
        Rectangle rVS = ventricleRoiS!=null?ventricleRoiS.getBounds():new Rectangle(0,0,ip.getWidth(),ip.getHeight());
        //^bounding RECTANGLE vs. non-rectangular shape issue
        
        for (int y=0; y<rVS.height; y++) {
            for (int x=0; x<rVS.width; x++) {
                if (maskVS==null||maskVS.getPixel(x,y)!=0) {
                    countVS++;
                }
            }
        }
        
        pixelValuesVS = new double[countVS];
        for (int y=0; y<rVS.height; y++) {
            for (int x=0; x<rVS.width; x++) {
                if (maskVS==null||maskVS.getPixel(x,y)!=0) {
                    pixelValuesVS[iteratorV]=ip.getPixelValue(x+rVS.x, y+rVS.y);
                    iteratorV++;
                }
            }
        }
        iteratorV = 0;
        
        //ATR DIASTOLE ANALYSIS-----------------------------------------------------------------------------------
        
        for (int sliceN=1;sliceN<=stackSize;sliceN++) {
            imp.setSlice(sliceN);
            pixelValuesAD2 = new double[countAD];
            for (int y=0; y<rAD.height; y++) {
                for (int x=0; x<rAD.width; x++) {
                    if (maskAD==null||maskAD.getPixel(x,y)!=0) {
                        pixelValuesAD2[iteratorA]=ip.getPixelValue(x+rAD.x, y+rAD.y);
                        iteratorA++;
                    }
                }
            }
            iteratorA = 0;
            corrAD = correlation(pixelValuesAD, pixelValuesAD2);
            tableData[tableRow][0]=""+sliceN;
            tableData[tableRow][1]=""+corrAD;
            tableRow++;
            //IJ.log("Frame #: " + sliceN);
            //IJ.log("Pearson's correlation coefficient: " + corrA);
            pixelValuesAD2 = null;
        }
        tableRow = 0;
        countAD = 0;
        
        //ATR SYSTOLE ANALYSIS-----------------------------------------------------------------------------------
        
        for (int sliceN=1;sliceN<=stackSize;sliceN++) {
            imp.setSlice(sliceN);
            pixelValuesAS2 = new double[countAS];
            for (int y=0; y<rAS.height; y++) {
                for (int x=0; x<rAS.width; x++) {
                    if (maskAS==null||maskAS.getPixel(x,y)!=0) {
                        pixelValuesAS2[iteratorA]=ip.getPixelValue(x+rAS.x, y+rAS.y);
                        iteratorA++;
                    }
                }
            }
            iteratorA = 0;
            corrAS = correlation(pixelValuesAS, pixelValuesAS2);
            tableData[tableRow][2]=""+corrAS;
            tableRow++;
            //IJ.log("Frame #: " + sliceN);
            //IJ.log("Pearson's correlation coefficient: " + corrA);
            pixelValuesAS2 = null;
        }
        tableRow = 0;
        countAS = 0;
        
        //VENTR DIASTOLE ANALYSIS-----------------------------------------------------------------------------------
        
        for (int sliceN2=1;sliceN2<=stackSize;sliceN2++) {
            imp.setSlice(sliceN2);
            pixelValuesVD2 = new double[countVD];
            for (int y=0; y<rVD.height; y++) {
                for (int x=0; x<rVD.width; x++) {
                    if (maskVD==null||maskVD.getPixel(x,y)!=0) {
                        pixelValuesVD2[iteratorV]=ip.getPixelValue(x+rVD.x, y+rVD.y);
                        iteratorV++;
                    }
                }
            }
            iteratorV = 0;
            corrVD = correlation(pixelValuesVD, pixelValuesVD2);
            tableData[tableRow][3]=""+corrVD;
            tableRow++;
            //IJ.log("Frame #: " + sliceN);
            //IJ.log("Pearson's correlation coefficient: " + corrA);
            pixelValuesVD2 = null;
        }
        tableRow = 0;
        countVD = 0;
        
        //VENTR SYSTOLE ANALYSIS-----------------------------------------------------------------------------------
        
        for (int sliceN2=1;sliceN2<=stackSize;sliceN2++) {
            imp.setSlice(sliceN2);
            pixelValuesVS2 = new double[countVS];
            for (int y=0; y<rVS.height; y++) {
                for (int x=0; x<rVS.width; x++) {
                    if (maskVS==null||maskVS.getPixel(x,y)!=0) {
                        pixelValuesVS2[iteratorV]=ip.getPixelValue(x+rVS.x, y+rVS.y);
                        iteratorV++;
                    }
                }
            }
            iteratorV = 0;
            corrVS = correlation(pixelValuesVS, pixelValuesVS2);
            tableData[tableRow][4]=""+corrVS;
            tableRow++;
            //IJ.log("Frame #: " + sliceN);
            //IJ.log("Pearson's correlation coefficient: " + corrA);
            pixelValuesVS2 = null;
        }
        tableRow = 0;
        countVS = 0;
        
        
        //create data table
        String column[]={"Frame #","r: AD", "r: AS", "r:VD", "r:VS"};
        final JTable resultsTable=new JTable(tableData,column);
        resultsTable.setBounds(20,20,440,350);
        JScrollPane spR=new JScrollPane(resultsTable);
        spR.setBorder(BorderFactory.createTitledBorder ("Data"));
        
        //save JTable in same directory as the video (under the same name but instead with the extension .txt)
        button = new JButton("Save");
        button.setBackground(Color.RED);
        button.setBounds(120, 0, 250, 30);
        button.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent e){
                try{
                    //the file path
                    JFileChooser fc = new JFileChooser();
                    File vidFile = new File(vidName);
                    String path2Vid = vidFile.getAbsolutePath();
                    if (path2Vid.indexOf(".") > 0){
                        path2Vid = path2Vid.substring(0, path2Vid.lastIndexOf("."));
                    }
                    File file = new File(path2Vid+".txt"); //change name of saved .txt file here
                    //if the file not exist create one
                    if(!file.exists()){
                        file.createNewFile();
                    }
                    
                    FileWriter fw = new FileWriter(file.getAbsoluteFile());
                    BufferedWriter bw = new BufferedWriter(fw);
                    
                    //loop for jtable rows
                    bw.write("\t   AD\t\tAS\t\t\tVD\t\tVS\n");
                    for(int i = 0; i < resultsTable.getRowCount(); i++){
                        //loop for jtable column
                        for(int j = 0; j < resultsTable.getColumnCount(); j++){
                            bw.write(resultsTable.getModel().getValueAt(i, j)+" ");
                        }
                        //break line at the begin
                        //break line at the end
                        bw.write("\n_________\n");
                    }
                    //close BufferedWriter
                    bw.close();
                    //close FileWriter
                    fw.close();
                    
                }catch(Exception ex){
                    ex.printStackTrace();
                }
            }
        });
        
        rTable.add(button);
        rTable.add(spR);
        rTable.setSize(500,500);
        rTable.setVisible(true);
        
        
        /*IJ.log("Atrium");
         IJ.log("Total pixel count: "+countA);
         //IJ.log("mean: "+IJ.d2s(sum/count,4));
         //IJ.log("1D pixel array: "+Arrays.toString(pixelValuesA));
         IJ.log("\n");
         IJ.log("Ventricle");
         IJ.log("Total pixel count: "+countV);
         //IJ.log("mean: "+IJ.d2s(sum/count,4));
         //IJ.log("1D pixel array: "+Arrays.toString(pixelValuesV));*/
        
        //create plot - currently set to graph frame # vs. atrium(diastole) data.
        frameNum = new double[stackSize]; //x-coordinates
        rNum = new double[stackSize]; //y-coordinates
        
        for(int fN = 0; fN<stackSize; fN++){
            frameNum[fN] = fN+1;
        }
        
        for(int rN = 0; rN<stackSize; rN++){
            temp = tableData[rN][1]; //change the number in the second pair of brackets next to tableData to r (corresponding to different ROI)
            rNum[rN] = Double.parseDouble(temp);
        }
        
        
        Plot resultsPlot = new Plot("Heart rate analysis","Frame #","R",frameNum,rNum);
        resultsPlot.setLimits(0, stackSize, 0, 1.1);
        
        rNum = null;
        
        resultsPlot.setColor(Color.blue);
        resultsPlot.draw();
        
        //create plot - currently set to graph frame # vs. atrium(systole) data.
        rNum2 = new double[stackSize]; //y-coordinates
        
        for(int rN2 = 0; rN2<stackSize; rN2++){
            temp = tableData[rN2][2]; //change the number in the second pair of brackets next to tableData to r (corresponding to different ROI)
            rNum2[rN2] = Double.parseDouble(temp);
        }
        
        
        resultsPlot.setColor(Color.red);
        resultsPlot.addPoints(frameNum, rNum2, Plot.LINE);
        resultsPlot.draw();
        
        //create plot - currently set to graph frame # vs. ventricle(diastole) data.
        rNum3 = new double[stackSize]; //y-coordinates
        
        for(int rN3 = 0; rN3<stackSize; rN3++){
            temp = tableData[rN3][3]; //change the number in the second pair of brackets next to tableData to r (corresponding to different ROI)
            rNum3[rN3] = Double.parseDouble(temp);
        }
        
        
        resultsPlot.setColor(Color.green);
        resultsPlot.addPoints(frameNum, rNum3, Plot.LINE);
        resultsPlot.draw();
        
        //create plot - currently set to graph frame # vs. ventricle(systole) data.
        rNum4 = new double[stackSize]; //y-coordinates
        
        for(int rN4 = 0; rN4<stackSize; rN4++){
            temp = tableData[rN4][4]; //change the number in the second pair of brackets next to tableData to r (corresponding to different ROI)
            rNum4[rN4] = Double.parseDouble(temp);
        }
        
        
        resultsPlot.setColor(Color.black);
        resultsPlot.addPoints(frameNum, rNum4, Plot.LINE);
        resultsPlot.draw();
        
        
        
        double xloc = 0.1;
        double yloc = .7;
        resultsPlot.setColor(Color.black);
        resultsPlot.addLabel(xloc, yloc, "AD");
        resultsPlot.addLabel(xloc, yloc+0.04,"AS");
        resultsPlot.addLabel(xloc, yloc+0.08,"VD");
        resultsPlot.addLabel(xloc, yloc+0.12,"VS");
        xloc += 0.01;
        yloc -= 0.01;
        resultsPlot.setColor(Color.blue);
        resultsPlot.drawNormalizedLine(xloc, yloc, xloc+0.1, yloc);
        resultsPlot.setColor(Color.red);
        resultsPlot.drawNormalizedLine(xloc, yloc+0.04, xloc+0.1, yloc+0.04);
        resultsPlot.setColor(Color.green);
        resultsPlot.drawNormalizedLine(xloc, yloc+0.08, xloc+0.1, yloc+0.08);
        resultsPlot.setColor(Color.black);
        resultsPlot.drawNormalizedLine(xloc, yloc+0.12, xloc+0.1, yloc+0.12);
        resultsPlot.show();
        
    }
    
    
    
    public static double sqr(double x) {
        return x*x;
    }
    
    
    //calculate correlation
    public static double correlation(double[] x, double[] y) {
        double sumx = 0;
        double sumy = 0;
        int n = x.length;
        for (int i=0; i<n; i++) {
            sumx += x[i];
            sumy += y[i];
        }
        double xmean = sumx/n;
        double ymean = sumy/n;
        double sum = 0;
        for (int i=0; i<n; i++)
            sum += (x[i]-xmean)*(y[i]-ymean);
        double sumx2 = 0;
        for (int i=0; i<n; i++)
            sumx2 += sqr(x[i]-xmean);
        double sumy2 = 0;
        for (int i=0; i<n; i++)
            sumy2 += sqr(y[i]-ymean);
        return sum/(Math.sqrt(sumx2)*Math.sqrt(sumy2));
    }
}
